핸들러 매핑과 핸들러 어댑터
===========================
# 📘 Controller 인터페이스
> Controller 인터페이스는 @Controller 애노테이션과는 전혀 다르다.
   
과거 버전 스프링 컨트롤러
```java  
org.springframework.web.servlet.mvc.Controller
```  
```java
@FunctionalInterface
public interface Controller {

	@Nullable
	ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;

}
```
스프링도 처음에는 이런 딱딱한 형식의 컨트롤러를 제공했다.
   
**Controller 인터페이스 구현체**   
```java
// 스프링 빈 이름을 URL에 맞추었다.
@Component("/springmvc/old-controller")
public class OldController implements Controller {

    @Override
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        System.out.println("OldController.handleRequest");
        return null;
    }

}
```
* **@Component :** `/springmvc/old-controller` 라는 이름으로 **스프링 빈 등록**   
* **빈의 이름으로 URL을 매핑할 것이다.**   

**컨트롤러는 어떻게 호출될 수 있을까? 🤔**   
   
![spring-mvc](https://user-images.githubusercontent.com/50267433/126873936-e90358e2-10ac-4b6e-9343-6d0c20c523fd.PNG)   
  
컨트롤러가 호출되려면 다음 2가지가 필요하다.   
    
**✔ HandlerMapping(핸들러 매핑)**
* 핸들러 매핑에서 컨트롤러를 찾을 수 있어야 한다.
* **스프링 빈의 이름으로 핸들러를 찾을 수 있는 핸들러 매핑이 필요하다.**    
     
**✔ HandlerAdapter(핸들러 어댑터)**  
* 핸들러 매핑을 통해서 찾은 핸들러를 실행할 수 있는 핸들러 어댑터가 필요하다.   
* **Controller 인터페이스를 실행할 수 있는 핸들러 어댑터를 찾고 실행해야 한다.**   
   
스프링은 이미 필요한 핸들러 매핑과 핸들러 어댑터를 대부분 구현해두었다.   
개발자가 직접 핸들러 매핑과 핸들러 어댑터를 만드는 일은 거의 없다.   
  
## 📖 핸들러 매핑과 핸들러 어댑터 프로세스    
스프링 부트가 자동 등록하는 핸들러 매핑과 핸들러 어댑터    
(실제로는 더 많지만, 중요한 부분 위주로 설명하기 위해 일부 생략)

**HandlerMapping**
```java
0 = RequestMappingHandlerMapping   : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = BeanNameUrlHandlerMapping      : 스프링 빈의 이름으로 핸들러를 찾는다.
```
   
**HandlerAdapter**   
```java
0 = RequestMappingHandlerAdapter   : 애노테이션 기반의 컨트롤러인 @RequestMapping에서 사용
1 = HttpRequestHandlerAdapter      : HttpRequestHandler 처리
2 = SimpleControllerHandlerAdapter : Controller 인터페이스(애노테이션X, 과거에 사용) 처리
```
핸들러 매핑도, 핸들러 어댑터도 모두 순서대로 찾고 만약 없으면 다음 순서로 넘어간다.      
url을 기준으로 `RequestMappingHandlerMapping`을 찾았는데 없기에     
다음 우선 순위인 `BeanNameUrlHandlerMapping`에서 찾아서 핸드러를 가져왔던 것이다.   
   
**1. 핸들러 매핑으로 핸들러 조회**  
1. `HandlerMapping` 을 순서대로 실행해서 핸들러를 찾는다.       
2. 이 경우 빈 이름으로 핸들러를 찾아야 하기 때문에         
   이름 그대로 빈 이름으로 핸들러를 찾아주는 `BeanNameUrlHandlerMapping` 가 실행에 성공하고     
   핸들러인 `OldController` 를 반환한다.     
   
**2. 핸들러 어댑터 조회**
1. `HandlerAdapter` 의 `supports()` 를 순서대로 호출한다.
2. `SimpleControllerHandlerAdapter` 가 Controller 인터페이스를 지원하므로 대상이 된다.
   
**3. 핸들러 어댑터 실행**   
1. 디스패처 서블릿이 조회한 `SimpleControllerHandlerAdapter` 를 실행하면서 핸들러 정보도 함께 넘겨준다.       
2. `SimpleControllerHandlerAdapter` 는 핸들러인 `OldController` 를 내부에서 실행하고, 그 결과를 반환한다.    
      
**정리 - OldController 핸들러매핑, 어댑터**         
OldController 를 실행하면서 사용된 객체는 다음과 같다.   
`HandlerMapping = BeanNameUrlHandlerMapping`    
`HandlerAdapter = SimpleControllerHandlerAdapter`    


