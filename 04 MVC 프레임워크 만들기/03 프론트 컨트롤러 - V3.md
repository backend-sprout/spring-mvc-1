프론트 컨트롤러 - V3
=======================  
   
서블릿 종속성 제거
컨트롤러 입장에서 HttpServletRequest, HttpServletResponse이 꼭 필요할까?
요청 파라미터 정보는 자바의 Map으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을
몰라도 동작할 수 있다.
그리고 request 객체를 Model로 사용하는 대신에 별도의 Model 객체를 만들어서 반환하면 된다.
우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경해보자.
이렇게 하면 구현 코드도 매우 단순해지고, 테스트 코드 작성이 쉽다.
뷰 이름 중복 제거
컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인할 수 있다.
컨트롤러는 뷰의 논리 이름을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화
하자.
이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.
/WEB-INF/views/new-form.jsp new-form
/WEB-INF/views/save-result.jsp save-result
/WEB-INF/views/members.jsp members

# 📘 V3 구조 

![v3](https://user-images.githubusercontent.com/50267433/126672741-b1935d82-b903-47b9-8fab-5f796d63bb6f.PNG)   
      
**ModelView**      
기존에는 `request.setAttribute()`를 사용하여 데이터를 저장하고 뷰에 전달했다.(Model 역할)                
그러나 `HttpServletRequest`를 그대로 사용하면 기능이 너무 많고 테스트 코드를 작성하기 어렵다.                        
서블릿 종속성 제거를 위해 **Model을 만들고, View 이름까지 전달하는 객체 `ModelView`를 만들어보자.**         

예제를 위한 `ModelView` 객체는 다른 버전에서도 사용하므로 패키지를 `frontcontroller`에 둔다.

## FrontController 
```java
@WebServlet(name = "frontControllerServletV3", urlPatterns = "/frontcontroller/v3/*")
public class FrontControllerServletV3 extends HttpServlet {
    
    private Map<String, ControllerV3> controllerMap = new HashMap<>();
    
    public FrontControllerServletV3() {
        controllerMap.put("/front-controller/v3/members/new-form", new MemberFormControllerV3());
        controllerMap.put("/front-controller/v3/members/save", new MemberSaveControllerV3());
        controllerMap.put("/front-controller/v3/members", new MemberListControllerV3());
    }
    
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String requestURI = request.getRequestURI();
        ControllerV3 controller = controllerMap.get(requestURI);
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Map<String, String> paramMap = createParamMap(request);
        ModelView mv = controller.process(paramMap);
        String viewName = mv.getViewName();
        MyView view = viewResolver(viewName);
        view.render(mv.getModel(), request, response);
    }
    
    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();
        request.getParameterNames().asIterator()
            .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
    
    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }
}
```
`FrontController`에서는 `HttpServletRequest request`를 활용해             
**`Map<String, String> paramMap`에 파라미터 이름과 그 값을 매핑하여 저장시킨다.**            
     
이후, 생성된 `paramMap`을 controller에 주입시켜 Model 값과 ViewName을 가진 `ModelView`를 반환하도록 한다.            
참고로, 이때 반환된 **`ViewName`은 단순한 경로만을 나타낸다.(prefix와 suffix를 가지 않은 경로)**          


## 📖 ModelView   
`ModelView`는 '뷰의 이름'과 '뷰를 렌더링할 때 필요한 model 객체'를 가지고 있다.    

```java
public class ModelView {

    private String viewName;
    private Map<String, Object> model = new HashMap<>();
    
    public ModelView(String viewName) {
        this.viewName = viewName;
    }
    public String getViewName() {
        return viewName;
    }
    public void setViewName(String viewName) {
        this.viewName = viewName;
    }
    public Map<String, Object> getModel() {
        return model;
    }
    public void setModel(Map<String, Object> model) {
       this.model = model;
    }
}
```   
Model은 단순히 Map으로 되어 있으므로 **Controller로부터 뷰에 필요한 데이터를 key, value로 받는다.**           
 
## 📖 Controller 인터페이스
```java
public interface ControllerV3 {
    ModelView process(Map<String, String> paramMap);
}
```
`HttpServletRequest`가 제공하는 **파라미터는 FrontController가 paramMap에 담아서 호출해주면 된다.**      
**응답 결과로 뷰 이름과 뷰에 전달할 Model 데이터를 포함하는 ModelView 객체를 반환하면 된다.**           

## 📖 Controller 구현체 - 회원 등록 폼
```java
public class MemberFormControllerV3 implements ControllerV3 {
 
    @Override
    public ModelView process(Map<String, String> paramMap) {
        return new ModelView("new-form");
    }
}
```
이전과 다르게 prefix, suffix를 제외한 view의 논리적인 이름만 저장한다.    
실제 물리적인 이름은 Front Controller 에서 처리하도록 

## 📖 Controller 구현체 - 회원 저장
```java
public class MemberSaveControllerV3 implements ControllerV3 {
    
    private MemberRepository memberRepository = MemberRepository.getInstance();
    
    @Override
    public ModelView process(Map<String, String> paramMap) {
        String username = paramMap.get("username");
        int age = Integer.parseInt(paramMap.get("age"));
        Member member = new Member(username, age);
        memberRepository.save(member);
        ModelView mv = new ModelView("save-result");
        mv.getModel().put("member", member);
        return mv;
    }
}
```   
   
* `paramMap.get("username");`    
  파라미터 정보는 map에 담겨있다.         
  map에서 필요한 요청 파라미터를 조회하면 된다.         
* `mv.getModel().put("member", member);`   
  모델은 단순한 map이므로 모델에 뷰에서 필요한 member 객체를 담고 반환한다.       
   
## 📖 MemberListControllerV3 - 회원 목록
```java
public class MemberListControllerV3 implements ControllerV3 {
    
    private MemberRepository memberRepository = MemberRepository.getInstance();
    
    @Override
    public ModelView process(Map<String, String> paramMap) {
        List<Member> members = memberRepository.findAll();
        ModelView mv = new ModelView("members");
        mv.getModel().put("members", members);
        return mv;
    }
}
```

```java
@WebServlet(name = "frontControllerServletV3", urlPatterns = "/frontcontroller/v3/*")
public class FrontControllerServletV3 extends HttpServlet {
    
    private Map<String, ControllerV3> controllerMap = new HashMap<>();
    
    public FrontControllerServletV3() {
        controllerMap.put("/front-controller/v3/members/new-form", new MemberFormControllerV3());
        controllerMap.put("/front-controller/v3/members/save", new MemberSaveControllerV3());
        controllerMap.put("/front-controller/v3/members", new MemberListControllerV3());
    }
 
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String requestURI = request.getRequestURI();
        ControllerV3 controller = controllerMap.get(requestURI);
        if (controller == null) {
            response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Map<String, String> paramMap = createParamMap(request);
        ModelView mv = controller.process(paramMap);
        String viewName = mv.getViewName();
        MyView view = viewResolver(viewName);
        view.render(mv.getModel(), request, response);
   }
 
    private Map<String, String> createParamMap(HttpServletRequest request) {
        Map<String, String> paramMap = new HashMap<>();
        request.getParameterNames().asIterator()
            .forEachRemaining(paramName -> paramMap.put(paramName, request.getParameter(paramName)));
        return paramMap;
    }
    
    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }
}
```

view.render(mv.getModel(), request, response) 코드에서 컴파일 오류가 발생할 것이다. 다음
코드를 참고해서 MyView 객체에 필요한 메서드를 추가하자.
createParamMap()
HttpServletRequest에서 파라미터 정보를 꺼내서 Map으로 변환한다. 그리고 해당 Map( paramMap )을
컨트롤러에 전달하면서 호출한다.
뷰 리졸버
MyView view = viewResolver(viewName)
컨트롤러가 반환한 논리 뷰 이름을 실제 물리 뷰 경로로 변경한다. 그리고 실제 물리 경로가 있는 MyView
객체를 반환한다.
논리 뷰 이름: members
물리 뷰 경로: /WEB-INF/views/members.jsp
view.render(mv.getModel(), request, response)
뷰 객체를 통해서 HTML 화면을 렌더링 한다.
뷰 객체의 render() 는 모델 정보도 함께 받는다.
JSP는 request.getAttribute() 로 데이터를 조회하기 때문에, 모델의 데이터를 꺼내서
request.setAttribute() 로 담아둔다.
JSP로 포워드 해서 JSP를 렌더링 한다.
  
## 📖 MyView
```java
public class MyView {
    
    private String viewPath;
    
    public MyView(String viewPath) {
        this.viewPath = viewPath;
    }
    
    public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
    
    public void render(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        modelToRequestAttribute(model, request);
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
 
    private void modelToRequestAttribute(Map<String, Object> model, HttpServletRequest request) {
        model.forEach((key, value) -> request.setAttribute(key, value));
    }
}
```
